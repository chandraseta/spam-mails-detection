core java technologies tech tip september arraylist vs linkedlist zero length array core java technologies technical tip code color font family verdana courier monospace font size pt pre color font family verdana courier monospace font size pt body div span color font family arial helvetica sans serif font size pt td th color font family arial helvetica sans serif font size pt tr color font family arial helvetica sans serif font size pt table font family arial helvetica sans serif font size pt p color font family arial helvetica sans serif font size pt li color font family arial helvetica sans serif font size pt br color font family arial helvetica sans serif font size pt div color font family arial helvetica sans serif font size pt sup font family arial helvetica sans serif font size pt h color font family arial helvetica sans serif font size pt h h h color font family arial helvetica sans serif font size pt blockquote input select color font family arial helvetica sans serif font size pt ul ol font color font family arial helvetica sans serif font size pt link font size pt font family arial helvetica sans serif color span purple font weight bold color font family arial helvetica sans serif font size pt span small font size pt font family arial helvetica sans serif color span link font size pt font family arial helvetica sans serif color view issue simple text september issue welcome core javatm technologies tech tip september get tip use core java technologies apis java platform standard edition jsetm use arraylist linkedlist use zero length array tip develop use java sdk standard edition v issue jdc tech tip write glen mccluskey use arraylist linkedlist arraylist linkedlist two collections class use store list object reference example could arraylist string linkedlist integers tip compare performance arraylist linkedlist offer suggestions class right choice give situation first key point arraylist back primitive object array arraylist much faster linkedlist random access access arbitrary list elements use get method note get method implement linkedlists require sequential scan front back list scan slow linkedlist fast way access nth element list consider follow example suppose large list sort elements either arraylist linkedlist suppose binary search list standard binary search algorithm start check search key value middle list middle value high upper half list eliminate however middle value low lower half list ignore process continue key find list lower bind search become greater upper bind program binary search elements arraylist linkedlist import java util public class listdemo static final int n static list value make list increase integer value static integer vals new integer n random rn new random int currval n vals new integer currval currval rn nextint value arrays aslist vals iterate across list look every value list use binary search static long timelist list lst long start int n look value list use binary search int indx lst values get sanity check result binary search indx system out println error n return start public static void main string args lookups arraylist system out println time arraylist timelist new arraylist value lookups linkedlist system out println time linkedlist timelist new linkedlist value listdemo program set list sort integer value add value arraylist linkedlist use search value list run program see result look something like time arraylist time linkedlist arraylist time faster linkedlist result might differ depend machine characteristics see distinct difference result arraylist compare linkedlist true program tip clearly linkedlist bad choice situation binary search algorithm inherently use random access linkedlist support fast random access time random access linkedlist proportional size list comparison random access arraylist fix time use randomaccess marker interface check whether list support fast random access void f list lst lst instanceof randomaccess support fast random access arraylist implement randomaccess interface linkedlist note take advantage randomaccess property optimize search result prove arraylist always better choice necessarily many case linkedlist better also note many situations algorithm implement efficiently linkedlist example reverse linkedlist use collections reverse internal algorithm get reasonable performance use forward backward iterators let us look another example suppose list elements lot element insert delete list case linkedlist better choice demonstrate consider follow worst case scenario demo program repeatedly insert elements begin list code look like import java util public class listdemo static final int n time long take add n object list static long timelist list lst long start object obj new object int n lst add obj return start public static void main string args time arraylist system out println time arraylist timelist new arraylist time linkedlist system out println time linkedlist timelist new linkedlist run program result look something like time arraylist time linkedlist result pretty much reverse previous example element add begin arraylist exist elements must push back mean lot expensive data movement copy contrast add element begin linkedlist simply mean allocate internal record element adjust couple link add begin linkedlist fix cost add begin arraylist cost proportional list size far tip look speed issue space let us look internal detail arraylist linkedlist implement java sdk standard edition v detail part external specification class illustrative class work internally linkedlist class private internal class define like private static class entry object element entry next entry previous entry object reference list element along next previous elements linkedlist word doubly linked list linkedlist elements entry object link together reference actual list elements significant space overhead linkedlist structure give entry object arraylist back object array store elements array start capacity array need grow new capacity compute newcapacity oldcapacity notice array capacity grow time mean arraylist large number elements significant amount space waste end waste intrinsic way arraylist work spare capacity array would reallocate new element performance would suffer dramatically change growth strategy aggressive double size reallocation would result slightly better performance would waste space know many elements arraylist specify capacity constructor also call trimtosize method fact reallocate internal array get rid waste space far discussion assume either arraylist linkedlist right give application sometimes choices make sense example consider common situation list key value pair would like retrieve value give key could store pair n x object array find right pair could sequential search key value approach work useful choice small list say elements less scale big list another approach sort key value pair ascend key value store result pair arraylists binary search key list approach also work fast yet another approach use list structure instead use map structure hash table form hashmap faster binary search arraylist hashmap final example compare two import java util public class listdemo static final int n list key value static list key static list value fill key list ascend order key value fill value list correspond value key static integer keyvec new integer n integer valuevec new integer n random rn new random int currval n keyvec new integer currval valuevec new integer currval currval rn nextint key arrays aslist keyvec value arrays aslist valuevec fill map key value pair static map map new hashmap static int n map put keys get values get binary search lookup key static long timelist long start int n int indx key keys get sanity check return value binary search indx system out println error n return start map lookup key static long timemap long start int n integer value integer map get keys get sanity check value return map lookup value values get system out println error n return start public static void main string args time list implementation system out println list time timelist time map implementation system out println map time timemap program set list key value use two different techniques map key value one approach use binary search list hash table run listdemo program get result look something like arraylist time hashmap time example n value approximately log n comparisons require average successful binary search binary search lookup arraylist take comparisons contrast properly implement hash table typically require comparisons expect hash table faster case however binary search still useful example might want lookup sort list find key close value key use lookup easy binary search impossible hash table key hash table store apparent random order also concern worst case performance binary search algorithm offer much stronger performance guarantee hash table scheme might also consider use treemap lookups sort collections key value pair let us summarize key point present tip append elements end list fix average cost arraylist linkedlist arraylist append typically involve set internal array location element reference occasionally result array reallocate linkedlist cost uniform involve allocate internal entry object insert delete elements middle arraylist imply rest list must move insert delete elements middle linkedlist fix cost linkedlist support efficient random access arraylist space overhead form reserve capacity end list linkedlist significant space overhead per element sometimes map structure better choice list information use arraylist linkedlists see section list section map sortedmap javatm program language third edition arnold gosling holmes also see collections trail java tutorial third edition back top use zero length array suppose write java application involve sort data filter raw data want clean process various ways one methods write take array integers along minimum maximum value method go array eliminate outliers value small big result filter process new array cleaned up data could implement kind filter method one approach import java util public class zerodemo filter input array throw away value less minval greater maxval static int filterdata int indata int minval int maxval check parameters errors indata null throw new nullpointerexception indata null maxval minval throw new maxval minval count number valid value input array int validcnt int indata length indata minval indata maxval validcnt valid value return null validcnt return null copy valid value new array return int outdata new int validcnt int j indata length indata minval indata maxval outdata j indata return outdata public static void main string args set test array integers int indata new int filter value range int outdata filterdata indata int outdata length system out println outdata filter value range int outdata filterdata indata int outdata length system out println outdata filterdata method two scan input array first scan count number valid data value method allocate new array appropriate size copy good value good value method return null value array reference result run zerodemo program exception thread main zerodemo main zerodemo java problem program rather basic one second call filterdata return null value program fail take possibility account better approach example would comment block code test possibility valid data value validcnt return null valid data code fall next line zero length array allocate int outdata new int perfectly legal java usage representation java array include length array therefore possible tell array zero length zerodemo example anticipate validcnt often zero data filter often eliminate value input could optimize away second input scan add code like int outdata new int validcnt validcnt return outdata note usage int outdata new int also legal initialize array zero length set integer constants general best return null method return array type always return array even array zero length greatly improve generality algorithms anticipate methods often return zero length array might concern performance implications allocate many array case allocate single array always return one follow private static final int zero_length_array new int array immutable change share throughout application another way zero length array use illustrate follow example import java util public class zerodemo public static void main string args set arraylist add string list stringlist new arraylist stringlist add string stringlist add string stringlist add string convert string array string string stringlist toarray new string int out length system out println result run zerodemo program string string string zerodemo program set arraylist add three string program call toarray get string array three elements arraylist example argument toarray new string argument serve couple purpose first string array big enough hold elements arraylist specify argument toarray method use string array array big enough toarray method allocate array return elements use type array pass determine type allocate array arraylist store element reference object array toarray method need tell type string use return array elements method use reflection create array appropriate type information use zero length array see item return zero length array nulls effective java program language guide joshua bloch back top important please read term use privacy license policies http http http comment send feedback javatm technology fundamentals newsletter jdc webmaster sun com subscribe follow newsletters latest information technologies products java platforms enterprise java technologies tech tip get tip use enterprise java technologies apis java platform enterprise edition jeetm wireless developer tech tip get tip use wireless java technologies apis java platform micro edition jmetm subscribe jdc publications go jdc newsletters publications page choose newsletters want subscribe click update unsubscribe go subscriptions page uncheck appropriate checkbox click update archive find core java technologies tech tip archive http copyright sun microsystems inc right reserve san antonio road palo alto california usa sun sun microsystems java java developer connection jse jee jme trademark register trademark sun microsystems inc unite state countries please send newsletters text please unsubscribe newsletter