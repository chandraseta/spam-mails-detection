synchronize scope strangeness apr pm hamish allan write hi rather puzzle behaviour see explain comment follow short category implementation nspersistentstore otadditions nsnumber nsstring key nsnumber number synchronize self nsmutabledictionary metadata self metadata mutablecopy need copy autorelease number original remain valid outside synchronize block number metadata objectforkey key copy autorelease number number nsnumber metadata setvalue nsnumber number forkey key self setmetadata metadata return number end behaviour see though nsnumber return metadata objectforkey key add special mini autorelease pool scoped synchronize block whereas autoreleased copy add normal autorelease pool least assume nsnumber deallocated symbolic breakpoints nsnumber release nsnumber dealloc remain pending state able confirm anyone tell go nothing relate synchronize problem acquire unretained pointer object something release object behind back number metadata objectforkey key number point object importantly objectforkey hand back pointer without result retain autorelease dance possible thing retain number metadata dictionary metadata setvalue something forkey key metadata release number may dead need careful objectforkey objectatindex mutate container methods avoid autorelease performance find also less safe solution copy autorelease correct retain autorelease might better greg parker gparker apple com runtime wrangler post admin request list ignore objc language mail list objc language lists apple com subscription http csmining org email send mlsubscriber tech csmining org